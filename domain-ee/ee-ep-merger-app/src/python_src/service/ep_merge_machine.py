import asyncio
import logging

from hoppy.exception import ResponseException
from src.python_src.service.claims_util import ClaimsUtil, MergeException
from src.python_src.service.hoppy_service import HoppyClientName, HoppyService
from src.python_src.service.merge_job import JobState, MergeJob
from statemachine import State, StateMachine


class EpMergeMachine(StateMachine):
    job: MergeJob | None = None

    # States:
    pending = State(initial=True, value=JobState.PENDING)
    running_set_temp_station_of_jurisdiction = State(value=JobState.RUNNING_SET_TEMP_STATION_OF_JURISDICTION)
    running_get_pending_contentions = State(value=JobState.RUNNING_GET_PENDING_CLAIM_CONTENTIONS)
    running_get_supplemental_contentions = State(value=JobState.RUNNING_GET_SUPP_CLAIM_CONTENTIONS)
    running_merge_contentions = State(value=JobState.RUNNING_MERGE_CONTENTIONS)
    running_update_pending_claim_contentions = State(value=JobState.RUNNING_UPDATE_PENDING_CLAIM_CONTENTIONS)
    running_cancel_supp_claim = State(value=JobState.RUNNING_CANCEL_SUPP_CLAIM)
    completed_success = State(final=True, value=JobState.COMPLETED_SUCCESS)
    completed_error = State(final=True, value=JobState.COMPLETED_ERROR)

    process = (
            pending.to(running_set_temp_station_of_jurisdiction)
            | running_set_temp_station_of_jurisdiction.to(running_get_pending_contentions, unless="has_error")
            | running_set_temp_station_of_jurisdiction.to(completed_error, cond="has_error")
            | running_get_pending_contentions.to(running_get_supplemental_contentions, unless="has_error")
            | running_get_pending_contentions.to(completed_error, cond="has_error")
            | running_get_supplemental_contentions.to(running_merge_contentions, unless="has_error")
            | running_get_supplemental_contentions.to(completed_error, cond="has_error")
            | running_merge_contentions.to(running_update_pending_claim_contentions, unless="has_error")
            | running_merge_contentions.to(completed_error, cond="has_error")
            | running_update_pending_claim_contentions.to(running_cancel_supp_claim, unless="has_error")
            | running_update_pending_claim_contentions.to(completed_error, cond="has_error")
            | running_cancel_supp_claim.to(completed_success, unless="has_error")
            | running_cancel_supp_claim.to(completed_error, cond="has_error")
    )

    def __init__(self, hoppy_service: HoppyService, merge_job: MergeJob):
        self.hoppy_service = hoppy_service
        self.job = merge_job
        super().__init__()

    def on_transition(self, source, target):
        logging.info(f"event=jobTransition job_id={self.job.job_id} old={source.id} new={target.id}")
        self.job.state = target.value

    @running_set_temp_station_of_jurisdiction.enter
    def on_set_temp_station_of_jurisdiction(self):
        # TODO use the response generated by the request.
        client = self.hoppy_service.get_client(HoppyClientName.PUT_TSOJ)
        tsoj = self.make_request(
            body={"claim_id": self.job.pending_claim_id, "SOJ": 398},
            hoppy_client=client)
        self.process(response=tsoj)

    @running_get_pending_contentions.enter
    def on_get_pending_contentions(self):
        # TODO use the response generated by the request.
        response = self.make_request(body={"claim_id": self.job.pending_claim_id},
                                     hoppy_client=self.hoppy_service.get_client(HoppyClientName.GET_CLAIM_CONTENTIONS))
        self.process(pending_contentions=response)

    @running_get_supplemental_contentions.enter
    def on_get_supplemental_contentions(self, pending_contentions=None):
        # TODO use the response generated by the request.
        response = self.make_request(body={"claim_id": self.job.supp_claim_id},
                                     hoppy_client=self.hoppy_service.get_client(HoppyClientName.GET_CLAIM_CONTENTIONS))
        self.process(pending_contentions=pending_contentions, supplemental_contentions=response)

    @running_merge_contentions.enter
    def on_merge_contentions(self, pending_contentions=None, supplemental_contentions=None):
        # TODO: add in logic to merge contentions into pending claim
        merged_claim = None
        try:
            merged_claim = ClaimsUtil.merge_claims(pending_contentions, supplemental_contentions)
        except MergeException as e:
            self.log_error(e)

        self.process(merged_claim=merged_claim)

    @running_update_pending_claim_contentions.enter
    def on_update_pending_claim_contentions(self, merged_claim=None):
        # TODO use the response generated by the request.
        self.make_request(
            body={"claim_id": self.job.supp_claim_id},
            hoppy_client=self.hoppy_service.get_client(HoppyClientName.UPDATE_CLAIM_CONTENTIONS))
        self.process()

    @running_cancel_supp_claim.enter
    def on_cancel_supp_claim(self):
        # TODO use the response generated by the request.
        self.make_request(
            body={"claim_id": self.job.supp_claim_id},
            hoppy_client=self.hoppy_service.get_client(HoppyClientName.CANCEL_CLAIM))
        self.process()

    @completed_success.enter
    def on_completed(self):
        # TODO add processing upon completion
        pass

    def make_request(self, body, hoppy_client):
        try:
            loop = asyncio.new_event_loop()
            req = hoppy_client.make_request(self.job.job_id, body)
            return loop.run_until_complete(req)
        except ResponseException as e:
            self.log_error(e)

    def has_error(self):
        return self.job.state == JobState.COMPLETED_ERROR

    def log_error(self, error):
        logging.error(f"event=errorProcessingJob "
                      f"job_id={self.job.job_id} "
                      f"state={self.job.state} "
                      f"error=\'{error.message}\'")
        self.job.error(self.job.state, error.message)
