buildscript {
  dependencies {
    classpath "org.yaml:snakeyaml:${snakeyaml_version}"
    //    classpath "se.patrikerdes:gradle-use-latest-versions-plugin:${use_latest_versions_plugin_version}"
    //    classpath "com.github.ben-manes:gradle-versions-plugin:${versions_plugin_version}"
  }
  // There's a conflict between versions of jgit between spotless and axion release plugin
  configurations.classpath {
    resolutionStrategy {
      force 'org.eclipse.jgit:org.eclipse.jgit:5.7.0.202003110725-r'
    }
  }
}

plugins {
  // Set versions for these plugins (but don't apply) so we don't have to specify the version later
  id 'org.ajoberstar.grgit' version '5.2.0' apply false
  id 'io.freefair.lombok' version '8.0.1' apply false
  id 'org.springframework.boot' version "${spring_boot_version}" apply false
  id 'io.swagger.swaggerhub' version '1.2.0' apply false
  id 'com.diffplug.spotless' version '5.14.1' apply false
  id 'com.palantir.docker' version '0.35.0' apply false
  id 'com.palantir.docker-run' version '0.35.0' apply false
  id 'net.rdrei.android.buildtimetracker' version '0.11.0' apply false
  id 'com.github.ben-manes.versions' version "${versions_plugin_version}" apply false
  id 'se.patrikerdes.use-latest-versions' version "${use_latest_versions_plugin_version}" apply false
  id 'com.github.johnrengelman.processes' version '0.5.0' apply false
  id 'org.springdoc.openapi-gradle-plugin' version '1.6.0' apply false
  id 'org.flywaydb.flyway' version '9.19.4' apply false
  id 'com.felipefzdz.gradle.shellcheck' version '1.4.6' apply false

  // Apply these
  id 'org.barfuin.gradle.jacocolog' version '3.1.0' // provides task jacocoAggregatedReport
  id 'org.barfuin.gradle.taskinfo' version '2.1.0'
  id 'nebula.lint' version '18.0.3'
  id 'pl.allegro.tech.build.axion-release' version '1.15.3'
  id 'starter.java.build-utils-property-conventions'
}

allprojects {
  apply plugin: 'nebula.lint'
  gradleLint {
    alwaysRun = false
    reportFormat = 'text'
    // https://github.com/nebula-plugins/gradle-lint-plugin/wiki
    rules = ['unused-dependency']
    // criticalRules will fail the build in the event of a violation
    criticalRules = [
      'minimum-dependency-version',
      'overridden-dependency-version',
      'unused-exclude-by-dep',
      'unused-exclude-by-conf',
      'dependency-parentheses',
      'duplicate-dependency-class',
      'archaic-wrapper',
      'all-nebula-renames'
    ]
  }

  afterEvaluate {
    // Workaround for gradleLint failure
    // https://github.com/nebula-plugins/gradle-lint-plugin/issues/336#issuecomment-844989277
    // https://github.com/gradle/gradle/issues/6854
    configurations.all {
      if (name.startsWith("incrementalScalaAnalysis")) {
        extendsFrom = []
      }
    }
  }

  apply plugin: 'com.diffplug.spotless'
  spotless {
    // to format build.gradle files consistently
    groovyGradle {
      greclipse()
      indentWithSpaces(2)
    }
  }
}

subprojects {
  task allDependencies(type: DependencyReportTask) {}

  pluginManager.withPlugin('java') {
    // List all failedTest at the end of a build -- copied from https://stackoverflow.com/a/43936442
    // add a collection to track failedTests
    ext.failedTests = []
    // add a listener to all tasks of type Test
    tasks.withType(Test) {
      afterTest { TestDescriptor descriptor, TestResult result ->
        if (result.resultType == org.gradle.api.tasks.testing.TestResult.ResultType.FAILURE) {
          failedTests << "${descriptor.className}::${descriptor.name}"
        }
      }
    }
    // print out tracked failed tests when the build has finished
    gradle.buildFinished {
      if (!failedTests.empty) {
        println "Failed tests:"
        failedTests.each { failedTest ->
          println "- " + failedTest
        }
        println ""
      }
    }
  }
}

ext {
  jacoco_enforce_violations = true
  jacoco_minimum_coverage = 0.8

  // Modules that use Java code
  codeModules = [
    ':app',
    ':shared:persistence-model',
    ':shared:lib-camel-connector',
    ':svc-lighthouse-api',
    ':console',
    ':mocks:mock-bip-ce-api',
    ':mocks:mock-bip-claims-api',
    ':mocks:mock-shared',
    ':mocks:mock-lighthouse-api',
    ':mocks:mock-slack',
    ':domain-xample:xample-api-controller',
    ':domain-xample:xample-shared',
    ':domain-xample:xample-workflows',
    ':domain-xample:svc-xample-j',
    ':domain-cc:cc-api-controller'
  ]
  // Modules that create Docker images
  dockerModules = [
    ':app',
    ':db-init',
    ':svc-bgs-api',
    ':svc-lighthouse-api',
    ':console',
    ':mocks:mock-bip-ce-api',
    ':mocks:mock-bip-claims-api',
    ':mocks:mock-lighthouse-api',
    ':mocks:mock-slack',
    ':domain-xample:xample-workflows',
    ':domain-xample:svc-xample-j',
    ':domain-cc:cc-app'
  ]
}

// Used by `release` task to create a new version
scmVersion {
  // never connect to remote
  localOnly = true
  useHighestVersion = true

  def postgresDockerfileContent=file("${project.rootDir}/postgres/src/docker/Dockerfile").getText()
  def matcher = (postgresDockerfileContent =~ /FROM postgres:(.+)/)
  def postgresBaseImageVersion = matcher.getCount() > 0 ? matcher[0][1] : "latest"
  Map<String, Object> platformHelmValues = new org.yaml.snakeyaml.Yaml().load(file("${project.rootDir}/helm/platform/values.yaml").text)
  def helmChartAppVersions = [
    // These rarely change
    'postgres'   : postgresBaseImageVersion, // extracted from Dockerfile
    'redis'      : (String) platformHelmValues.get("redis-chart").get("imageTag"),
    'rabbitmq'   : (String) platformHelmValues.get("rabbitmq-chart").get("imageTag"),

    // Stable versions -- changes occasionally
    'console'    : '2.5.0',

    // These change often (i.e., with each release)
    // A null value will result in the currentVersion being used
    '..'         : null, // '..' will resolve to helm/Charts.yaml
    'api-gateway': null, // Update the version presented in SwaggerUI
    'vro-app'    : null,
    'vro-svcs'   : null,
    // Once stable, set a version and move to previous section
    'domain-cc'  : null,
  ]

  def setHelmChartAppVersions = { currentVersion ->
    helmChartAppVersions.collect { projectName, version ->
      if (version == null) version = currentVersion

      def helmChartFilePaths = [
        project.findProperty("helm.${projectName}.chart_file"),
        "/helm/${projectName}/Chart.yaml",
        "/helm/platform/charts/${projectName}/Chart.yaml",
        "/helm/vro/charts/${projectName}/Chart.yaml"
      ]
      def helmChartFilePath = helmChartFilePaths.find{ it != null && file("${project.rootDir}/$it").exists() }
      println String.format( "%-14s %-12s => %s", projectName, version, helmChartFilePath)
      if (version != null && helmChartFilePath != null) {
        def helmChartFile = file("${project.rootDir}/$helmChartFilePath")
        String s = helmChartFile.text.replaceFirst(/(?m)^appVersion: ".*"/, "appVersion: \"$version\"")
        helmChartFile.setText(s)
        helmChartFile
      }
    }
  }

  hooks {
    pre("fileUpdate", [file: "api-gateway/src/main/java/gov/va/vro/propmodel/Info.java",
      pattern    : { v, p -> /version = "v.*"/ },
      replacement: { v, p -> "version = \"v$v\"" }])
    pre({ context ->
      setHelmChartAppVersions(context.currentVersion)
          .findAll{ it !=null }.each { file -> context.addCommitPattern(file.canonicalPath) }
    })
    pre("commit")
  }
}

allprojects {
  // https://axion-release-plugin.readthedocs.io/en/latest/configuration/basic_usage
  project.version = scmVersion.version
}

def maintainerclean = tasks.register('maintainerclean') {
  group = "Workflow"
  description = "clean all submodules"
  def tb = taskBuilder('clean')
  codeModules.each { dependsOn tb(it) }
  dockerModules.each { dependsOn tb(it) }
  //depender codeModules, taskBuilder('clean')
  //depender dockerModules, taskBuilder('clean')
}

def dockerclean = tasks.register('dockerclean') {
  group = "Workflow"
  description = "clean docker images"
  dependsOn ':app:dockerComposeDown'
  dependsOn ':app:dockerPrune'
}

def dockermaintainerclean = tasks.register('dockermaintainerclean') {
  group = "Workflow"
  description = "clean docker images"
  dependsOn ':app:dockerPruneVolume'
  mustRunAfter dockerclean
}

def devloop = tasks.register('devloop') {
  group = "Workflow"
  description = "Rebuild code, docker images, and restart docker-compose"
  dependsOn ':app:build'
  def tb = taskBuilder('docker')
  dockerModules.each { dependsOn tb(it) }
  //depender(dockerModules, taskBuilder('docker'))
  dependsOn ':app:dockerComposeUp'
  mustRunAfter dockerclean
  mustRunAfter dockermaintainerclean
}

def restartloop = tasks.register('restartloop') {
  group = "Workflow"
  description = "Stop docker-compose, delete unused images, continue with devloop task"
  dependsOn dockerclean
  dependsOn devloop
}

tasks.register('resetloop') {
  group = "Workflow"
  description = "Remove docker volumes, continue with restartloop task"
  dependsOn dockerclean
  dependsOn dockermaintainerclean
  dependsOn restartloop
}
